package org.combinators.solitaire.archway

import com.github.javaparser.ast.body.{FieldDeclaration, MethodDeclaration}
import com.github.javaparser.ast.expr.{Expression, Name, SimpleName}
import com.github.javaparser.ast.ImportDeclaration
import com.github.javaparser.ast.stmt.Statement
import de.tu_dortmund.cs.ls14.cls.interpreter.combinator
import de.tu_dortmund.cs.ls14.cls.types._
import de.tu_dortmund.cs.ls14.cls.types.syntax._
import de.tu_dortmund.cs.ls14.twirl.Java
import domain._
import domain.archway._
import org.combinators.solitaire.shared._
import org.combinators.solitaire.shared.compilation.{CodeGeneratorRegistry, constraintCodeGenerators}

/**
  * Defines Java package, the game's name, initializes the domain model,
  * the UI, and the controllers (doesn't define them, just generates),
  * and includes extra fields and methods.
  * TODO: Score52...
  */
class ArchwayDomain(override val solitaire: Solitaire) extends SolitaireDomain(solitaire) with GameTemplate with Score52 with Controller {

  /**
    * Freecell requires specialized extensions for constraints to work.
    */
  @combinator object DefaultGenerator {
    def apply: CodeGeneratorRegistry[Expression] = constraintCodeGenerators.generators
    val semanticType: Type = constraints(constraints.generator)
  }

  @combinator object HelperMethodsArchway {
    def apply(): Seq[MethodDeclaration] = Seq.empty

    val semanticType: Type = constraints(constraints.methods)
  }

  @combinator object RootPackage {
    def apply: Name = Java("org.combinators.solitaire.archway").name()
    val semanticType: Type = packageName
  }

  @combinator object NameOfTheGame {
    def apply: SimpleName = Java("Archway").simpleName()
    val semanticType: Type = variationName
  }

  /**
    * Creates the objects used in the game, and associates them with their View classes.
    * - Deck (which has no view in Archway), Tableau, Reserve, Foundation.
    * The names are copied from those generated by the ExtraFields combinator.
    */
  @combinator object ArchwayInitModel {

    // note: we could avoid passing in these parameters and just solely
    // visit the domain model. That is an alternative worth considering.

    def apply(): Seq[Statement] = {

      /**
        * I'll add the deck to the model, but in 'Init('InitialDeal),
        * I need to remove all the cards and add them back from a
        * temporary deck in order to set up the Aces and Kings Foundations.
        */
      val deck = deckGen("deck", solitaire.containers.get(SolitaireContainerTypes.Stock))

      val reserve = loopConstructGen(solitaire.containers.get(SolitaireContainerTypes.Reserve), "fieldPiles", "fieldPileViews", "Pile")
      val tableau = loopConstructGen(solitaire.containers.get(SolitaireContainerTypes.Tableau), "fieldColumns", "fieldColumnViews", "Column")

      /*
       * The Foundation is split between Aces and Kings, so I have to manually
       * generate them instead of using loopConstructGen()
       */
      val aces = loopConstructGen(solitaire.containers.get(SolitaireContainerTypes.Foundation), "fieldAcesUpPiles", "fieldAcesUpPileViews", "AcesUpPile")

      val kings = loopConstructGen(solitaire.containers.get(ArchwayContainerTypes.KingsDown), "fieldKingsDownPiles", "fieldKingsDownPileViews", "KingsDownPile")


      deck ++ aces ++ kings ++ reserve ++ tableau
    }

    val semanticType: Type = game(game.model)
  }

  /** Deal the cards.
    * There is no mechanism to instantiate individual cards, so in order to create
    * the Aces and Kings Foundation, I have to create a temporary deck,
    * manually remove the Aces and Kings, add them to the foundation, and add
    * the rest back to the original deck.
    */
  @combinator object ArchwayInitLayout {
    def apply(): Seq[Statement] = {
      Java(
        s"""
           |deck.removeAll();
           |
           |MultiDeck tmpDeck = new MultiDeck(2);
           |tmpDeck.create(seed);
           |tmpDeck.shuffle(seed);
           |
           |// Remove the Aces and Kings and place them in the Foundation.
           |for (int i = 0; i < 104; i++) {
           |  Card card = tmpDeck.get();
           |  String card_string = card.toString();
           |
           |  if (card_string.equals("AH")) { fieldAcesUpPiles[0].add(card); }
           |  else if (card_string.equals("AS")) {
           |    fieldAcesUpPiles[1].add(card);
           |  }
           |  else if (card_string.equals("AC")) {
           |    fieldAcesUpPiles[2].add(card);
           |  }
           |  else if (card_string.equals("AD")) {
           |    fieldAcesUpPiles[3].add(card);
           |  }
           |  else if (card_string.equals("KH")) {
           |    fieldKingsDownPiles[0].add(card);
           |  }
           |  else if (card_string.equals("KS")) {
           |    fieldKingsDownPiles[1].add(card);
           |  }
           |  else if (card_string.equals("KC")) {
           |    fieldKingsDownPiles[2].add(card);
           |  }
           |  else if (card_string.equals("KD")) {
           |    fieldKingsDownPiles[3].add(card);
           |  }
           |  else {
           |    deck.add(card);
           |  }
           |}
           |
           |// Fill the Tableau.
           |for (int i = 0; i < 12; i++) {
           |  for (int j = 0; j < 4; j++) {
           |    fieldColumns[j].add(deck.get());
           |  }
           |}
           |
           |// The rest goes to the Reserves.
           |for (int i = 0; i < 40; i++) {
           |  Card card = deck.get();
           |  fieldPiles[card.getRank() - 2].add(card);
           |}
         """.stripMargin).statements()
    }

    val semanticType: Type = game(game.deal)
  }

  /*
   * Because Aces and Kings have differing behavior in the Foundation, I have to make them as subclasses.
   */
  @combinator object MakeAcesUpPile        extends ExtendModel("Pile",    "AcesUpPile",    'AcesUpPileClass)
  @combinator object MakeKingsDownPile     extends ExtendModel("Pile",    "KingsDownPile", 'KingsDownPileClass)
  @combinator object MakeAcesUpPileView    extends ExtendView("PileView", "AcesUpPileView",    "AcesUpPile",    'AcesUpPileViewClass)
  @combinator object MakeKingsDownPileView extends ExtendView("PileView", "KingsDownPileView", "KingsDownPile", 'KingsDownPileViewClass)

  /**
    * Generate the statements which set the location of the Views.
    */
  @combinator object ArchwayInitView {
    def apply(): Seq[Statement] = {


      var stmts = layout_place_it(solitaire.containers.get(SolitaireContainerTypes.Foundation), Java("fieldAcesUpPileViews").name())
      stmts = stmts ++ layout_place_it(solitaire.containers.get(SolitaireContainerTypes.Reserve), Java("fieldPileViews").name())
      stmts = stmts ++ layout_place_it(solitaire.containers.get(SolitaireContainerTypes.Tableau), Java("fieldColumnViews").name())
      stmts = stmts ++ layout_place_it(solitaire.containers.get(ArchwayContainerTypes.KingsDown), Java("fieldKingsDownPileViews").name())

      stmts

    }
    val semanticType: Type = game(game.view)
  }

  /**
    * Generate code to associate Views with Controllers,
    * and to associate Controllers with Mouse Adapters.
    */
  @combinator object ArchwayInitControl {
    def apply(NameOfGame: SimpleName): Seq[Statement] = {
      val name = NameOfGame.toString()

      /* Aces Foundation Controller */
      val aces = loopControllerGen(solitaire.containers.get(SolitaireContainerTypes.Foundation), "fieldAcesUpPileViews", "AcesUpPileController")

      /* Kings Foundation Controller */
      val kings = loopControllerGen(solitaire.containers.get(ArchwayContainerTypes.KingsDown), "fieldKingsDownPileViews", "KingsDownPileController")

      /* Tableau Controller */
      val tableau = loopControllerGen(solitaire.containers.get(SolitaireContainerTypes.Tableau), "fieldColumnViews", "ColumnController")

      /* Reserve Controller */
      val reserve = loopControllerGen(solitaire.containers.get(SolitaireContainerTypes.Reserve), "fieldPileViews", "PileController")

      aces ++ kings ++ tableau ++ reserve
    }

    val semanticType: Type = variationName =>: game(game.control)
  }

  /**
    * Generates import statements for the model and controller packages.
    */
  @combinator object ExtraImports {
    def apply(nameExpr: Name): Seq[ImportDeclaration] = {
      Seq(
        Java(s"import $nameExpr.controller.*;").importDeclaration(),
        Java(s"import $nameExpr.model.*;").importDeclaration()
      )
    }
    val semanticType: Type = packageName =>: game(game.imports)
  }

  /**
    * Generate extra methods. Here we only need the preferred window size of the game.
    */
  @combinator object ExtraMethods {
    def apply(): Seq[MethodDeclaration] = {
      Java(s"""|public Dimension getPreferredSize() {
               |  return new Dimension (1280, 1280);
               |}
               |
               |// Available moves based on this variation. Note this was hard-coded in generated code
               |// and then manually moved into this combinator.
               |public java.util.Enumeration<Move> availableMoves() {
               |		java.util.Vector<Move> v = new java.util.Vector<Move>();
               |
               |	// Try all moves from the Reserve to the Aces and Kings Foundation and the Tableau.
               |  for (Pile reserve : fieldPiles) {
               |
               |    for (AcesUpPile acesFoundation : fieldAcesUpPiles) {
               |      ReserveToFoundation rtf = new PotentialReserveToFoundation(reserve, acesFoundation);
               |      if (rtf.valid(this)) {
               |        v.add(rtf);
               |      }
               |    }
               |    for (KingsDownPile kingsFoundation : fieldKingsDownPiles) {
               |      ReserveToKingsFoundation rkf = new PotentialReserveToKingsFoundation(reserve, kingsFoundation);
               |      if (rkf.valid(this)) {
               |        v.add(rkf);
               |      }
               |    }
               |    for (Column tableau : fieldColumns) {
               |      ReserveToTableau rt = new PotentialReserveToTableau(reserve, tableau);
               |      if (rt.valid(this)) {
               |        v.add(rt);
               |      }
               |    }
               |  }
               |
               |  // Try all moves from the Tableau to the Aces and Kings Foundation.
               |  for (Column tableau : fieldColumns) {
               |    for (AcesUpPile acesFoundation : fieldAcesUpPiles) {
               |      TableauToFoundation tf = new PotentialTableauToFoundation(tableau, acesFoundation);
               |      if (tf.valid(this)) {
               |        v.add(tf);
               |      }
               |    }
               |
               |    // TODO: The 3H is duplicated when returned to the Tableau.
               |    for (KingsDownPile kingsFoundation : fieldKingsDownPiles) {
               |      TableauToKingsFoundation tk = new PotentialTableauToKingsFoundation(tableau, kingsFoundation);
               |      if (tk.valid(this)) {
               |        v.add(tk);
               |      }
               |    }
               |  }
               |
               |  return v.elements();
               |	}
               |
               |""".stripMargin).classBodyDeclarations().map(_.asInstanceOf[MethodDeclaration])

    }

    val semanticType: Type = game(game.methods :&: game.availableMoves)
  }

  /**
    * Generate Archway.java's attributes:
    * one array for the domain model and one array for the view, and any other fields
    * Ex: Multideck deck;
    *     Pile reservePiles = new Pile[11];
    *     PileView reservePileViews = new PileView[11];
    */
  @combinator object ExtraFields {
    def apply(): Seq[FieldDeclaration] = {
      val fields =
        Java(
          s"""
             |IntegerView scoreView;
             |IntegerView numLeftView;
             """.stripMargin).classBodyDeclarations().map(_.asInstanceOf[FieldDeclaration])

      /* The first argument becomes fieldColumns */
      val tableau = fieldGen("Column",        solitaire.containers.get(SolitaireContainerTypes.Tableau).size)
      val reserve = fieldGen("Pile",          solitaire.containers.get(SolitaireContainerTypes.Reserve).size)
      val aces    = fieldGen("AcesUpPile",    solitaire.containers.get(SolitaireContainerTypes.Foundation).size)
      val kings   = fieldGen("KingsDownPile", solitaire.containers.get(ArchwayContainerTypes.KingsDown).size)

      val deck = deckFieldGen(solitaire.containers.get(SolitaireContainerTypes.Stock))

      deck ++ fields ++ tableau ++ reserve ++ aces ++ kings
    }

    val semanticType: Type = game(game.fields)
  }
}
